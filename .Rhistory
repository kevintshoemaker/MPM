# plot(agedf[,c("age","surv")])
}
agedf$surv
prev=0
ns
ss = c(js$mean,as)
ss
thisdur = t[[1]][1]
thisdur
t[[1]][z]
t
z=1
prev=0
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
thisramp
z
ss[z+1]
js$min[z]
js$mean[z]
js
thisdur = t[[1]][z]
t
prev=0
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
agedf$surv[prev+(1:length(thisramp))] = thisramp
agedf$surv
z=2
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
thisramp
js
agedf$surv[prev+(1:length(thisramp))] = thisramp
plot(agedf[,c("age","surv")])
agedf$surv
prev=0
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
z=1
prev=0; z=1
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
agedf$surv[prev+(1:length(thisramp))] = thisramp
agedf$surv
prev
prev=length(thisramp)
prev=0; z=1
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
agedf$surv[prev+(1:length(thisramp))] = thisramp
prev=length(thisramp)
prev
z=2
ss = c(js$mean,as); thisdur = t[[1]][z]
thisramp = ramp_fun(js$mean[z],js$min[z],ss[z+1],thisdur)
agedf$surv[prev+(1:length(thisramp))] = thisramp
prev=length(thisramp)
agedf$surv
plot(agedf[,c("age","surv")])
scen6 <- gen_scen(jsurv=data.frame(mean=c(0.5,0.8),min=c(0.25,0.65)),asurv=0.95, fec=1.29, dur=c(3,4))
prev=ns+1; z=1
t[[prev-1]][z]
t
ss = c(js$mean,as); thisdur = t[[1]][prev-1]
thisdur
js$mean[prev-1]
ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],ss[prev],thisdur)
thisramp
ndx = nrow(agedf)
ndx
(ndx-length(thisramp)+1):ndx
thisramp
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1
ss = c(js$mean,as); thisdur = t[[1]][prev-1]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],ss[prev],thisdur)
thisramp
prev=ns+1; z=1; ndx = nrow(agedf)
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
agedf$surv
prev=prev-1; thismax=min(thisramp)
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
thisramp
thismax
prev=ns+1; z=1; ndx = nrow(agedf)
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1; thismax=min(thisramp)
thismax
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1; thismax=min(thisramp)
plot(agedf[,c("age","surv")])
agedf$surv
prev=ns+1; z=1; ndx = nrow(agedf)
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
agedf$surv
prev=prev-1; thismax=min(thisramp)
ss = c(js$mean,as); thisdur = t[[1]][prev-1]; thismax = ss[prev]
thismax
prev=ns+1; z=1; ndx = nrow(agedf); ss = c(js$mean,as); thismax = ss[prev]
thisdur = t[[1]][prev-1];
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1; thismax=min(thisramp)
thisdur = t[[1]][prev-1];
thisdur
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
thisramp
(ndx-length(thisramp)+1)
ndx
prev=ns+1; z=1; ndx = nrow(agedf); ss = c(js$mean,as); thismax = ss[prev]
thisdur = t[[1]][prev-1];
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1; thismax=min(thisramp); ndx=ndx-length(thisramp)
thisdur = t[[1]][prev-1];
thisramp = ramp_fun(js$mean[prev-1],js$min[prev-1],thismax,thisdur)
ndx
ndx-length(thisramp)+1
ndx
agedf$surv[(ndx-length(thisramp)+1):ndx] = thisramp
prev=prev-1; thismax=min(thisramp); ndx=ndx-length(thisramp)
plot(agedf[,c("age","surv")])
source("MPM_Functions_v0_1.R")
rm(list=ls())
library(popbio)  # package for matrix population models
library(Rsolnp)   # package for nonlinear constrained optimization (eg. for finding maxent probability distributions)
library(memoise)
source("MPM_Functions_v0_1.R")
# jsurv=0.75; asurv=0.96; fec=0.5; dur=9
scen1 <- gen_scen(jsurv=0.75, asurv=0.96, fec=0.5, dur=9)
scen2 <- gen_scen(jsurv=c(0.75,0.96),asurv=0.96,fec=0.5,dur=c(6,3))
scen3 <- gen_scen(jsurv=c(0.75),asurv=0.96,fec=0.5,dur=data.frame(dur=9,min=6,max=13))   # variable stage duration
scen4 <- gen_scen(jsurv=c(0.6,0.8),asurv=0.96,fec=0.5,dur=data.frame(dur=c(4,3),min=c(2,2),max=c(5,5)))   # variable stage duration
scen5 <- gen_scen(jsurv=data.frame(mean=0.75,min=0.5),asurv=0.95, fec=1.29, dur=9)
scen6 <- gen_scen(jsurv=data.frame(mean=c(0.5,0.8),min=c(0.25,0.65)),asurv=0.95, fec=1.29, dur=c(3,4))
scen7 <- gen_scen(jsurv=data.frame(mean=0.75,min=0.5),asurv=0.95, fec=1.29, dur=data.frame(dur=9,min=6,max=13))
scen8 <- gen_scen(jsurv=data.frame(mean=c(0.6,0.8),min=c(0.3,0.6)),asurv=0.95, fec=1.29, dur=data.frame(dur=c(3,5),min=c(1,3),max=c(3,8) ))
# js=scen1$jsurv;as=scen1$asurv;f=scen1$fec;t=scen1$dur
mat <- do_aas(js=scen1$jsurv,as=scen1$asurv,f=scen1$fec,t=scen1$dur)    # AAS
mat
lambda(mat)
rm(list=ls())
library(popbio)  # package for matrix population models
library(Rsolnp)   # package for nonlinear constrained optimization (eg. for finding maxent probability distributions)
library(memoise)
source("MPM_Functions_v0_1.R")
# jsurv=0.75; asurv=0.96; fec=0.5; dur=9
scen1 <- gen_scen(jsurv=0.75, asurv=0.96, fec=0.5, dur=9)
scen2 <- gen_scen(jsurv=c(0.75,0.96),asurv=0.96,fec=0.5,dur=c(6,3))
scen3 <- gen_scen(jsurv=c(0.75),asurv=0.96,fec=0.5,dur=data.frame(dur=9,min=6,max=13))   # variable stage duration
scen4 <- gen_scen(jsurv=c(0.6,0.8),asurv=0.96,fec=0.5,dur=data.frame(dur=c(4,3),min=c(2,2),max=c(5,5)))   # variable stage duration
scen5 <- gen_scen(jsurv=data.frame(mean=0.75,min=0.5),asurv=0.95, fec=1.29, dur=9)
scen6 <- gen_scen(jsurv=data.frame(mean=c(0.5,0.8),min=c(0.25,0.65)),asurv=0.95, fec=1.29, dur=c(3,4))
scen7 <- gen_scen(jsurv=data.frame(mean=0.75,min=0.5),asurv=0.95, fec=1.29, dur=data.frame(dur=9,min=6,max=13))
scen8 <- gen_scen(jsurv=data.frame(mean=c(0.6,0.8),min=c(0.3,0.6)),asurv=0.95, fec=1.29, dur=data.frame(dur=c(3,5),min=c(1,3),max=c(3,8) ))
# js=scen1$jsurv;as=scen1$asurv;f=scen1$fec;t=scen1$dur
mat <- do_aas(js=scen1$jsurv,as=scen1$asurv,f=scen1$fec,t=scen1$dur)    # AAS
mat
lambda(mat)
# js=scen1$jsurv;as=scen1$asurv;f=scen1$fec;t=scen1$dur
mat <- do_unroll(scen1$jsurv,scen1$asurv,scen1$fec,scen1$dur)   # unroll
mat
lambda(mat)       # gives the same result as AAS- as it should!
mat <- do_fas(scen1$jsurv,scen1$asurv,scen1$fec,scen1$dur)  # FAS
mat
lambda(mat)  # 1.065  --- 6.5% growth rate per year   - much higher growth rate!!!
# js=scen2$jsurv;as=scen2$asurv;f=scen2$fec;t=scen2$dur
mat <- do_aas(scen2$jsurv,scen2$asurv,scen2$fec,scen2$dur)    # AAS
mat
lambda(mat)
mat <- do_unroll(scen2$jsurv,scen2$asurv,scen2$fec,scen2$dur)   # unroll
mat
lambda(mat)       # gives the same result as AAS- as it should!
mat <- do_fas(scen2$jsurv,scen2$asurv,scen2$fec,scen2$dur)  # FAS
mat
lambda(mat)  # still higher, but not as wrong
scen4
scen3
# scen3
# js=scen3$jsurv; as=scen3$asurv; f=scen3$fec; t=scen3$dur
mat <- do_aas(scen3$jsurv,scen3$asurv,scen3$fec,scen3$dur)   # aas- gives warning message
mat
lambda(mat)
mat <- do_unroll(scen3$jsurv,scen3$asurv,scen3$fec,scen3$dur)   # very minor difference from fixed duration!!
mat
lambda(mat)
# scen4
# js=scen4$jsurv;as=scen4$asurv;f=scen4$fec;t=scen4$dur
mat <- do_unroll(scen4$jsurv,scen4$asurv,scen4$fec,scen4$dur)   # very minor difference from fixed duration!!
mat
lambda(mat)
scen5
js=scen5$jsurv;as=scen5$asurv;f=scen5$fec;t=scen5$dur
# scen5
# js=scen5$jsurv;as=scen5$asurv;f=scen5$fec;t=scen5$dur
mat <- do_unroll(scen5$jsurv,scen5$asurv,scen5$fec,scen5$dur)
mat
2200/5
22000/5
22000/6
11000/5
1700*5
1700*10
1700*12
11000/5
11000/6
1700*6
10200/5
11000/5
# FUNCTIONS for matrix population modeling in R ----------
## Initial error checking function ------------
# s is stage specific survival, l is lambda, T is focal stage duration
init_input_check <- function(js,as,f,t){
if (!is.data.frame(js)) {
stop("Argument 'js' (juv surv) must be data frame")
}
if (!all(sapply(js,is.numeric))){
stop("All columns of data frame 'js' must be numeric")
}
if (length(as)>1) {
stop("adult survival must be a single value")
}
if (!is.numeric(as)){
stop("adult survival must be numeric")
}
if (length(f)>1) {
stop("fecundity must be a single value")
}
if (!is.numeric(f)){
stop("fecundity must be numeric")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
## Scenario generating function -------------
gen_scen <- function(jsurv,asurv,fec,dur){
if(is.vector(dur)) dur = data.frame(dur=dur)
nst = length(jsurv) + 1
if(is.vector(jsurv)) jsurv = data.frame(mean=jsurv)
scen <- list()
scen$jsurv = jsurv
scen$asurv = asurv
scen$fec = fec  # annual fecundity (assume pre-breeding census- this represents the number of new one-year-olds entering the population next year)
scen$dur = dur  # duration of juvenile stage (mean, min, max)
scen
}
## Functions for AAS method ---------------
#  Assume pre-breeding census
#  s is vector of survival, f is fecundity (scalar), t is duration of juvenile stage
#  l is lambda, mat is a stage matrix...
gamma_aas <- function(s,l,t){
sl = s/l
if(sl==1) 0.5 else (sl^(t-1)*(1-sl)) / (1-sl^t)  # note that the formula involves the sum of finite geometric series so can be simplified
}
# s is survival of focal stage, l is current lambda estimate, t is duration of focal stage
thistrans_aas <- function(s,l,t){
gam = gamma_aas(s,l,t)   # compute gamma (fraction of survivors transitioning)
c(s*(1-gam),s*gam)    # allocate the transitions
}
# s is survival of all stages, f is fecundity of final stage, t is duration of juvenile stages
do_aas <- function(js,as,f,t){
init_input_check(js,as,f,t)
ss = c(js[[1]],as)
n=length(ss); m0 <- matrix(0,n,n) ; m0[n,n] <- ss[n] ;  m0[1,n] <- f    # construct init matrix
lam = 1  # take an initial guess at lambda
dif=Inf ; tol=1e-6
while(dif>tol){
l = popbio::lambda(m0)
for(g in 1:(n-1)) m0[g:(g+1),g] = thistrans_aas(ss[g],l,t[[1]][g])
dif = abs(lambda(m0) - l)
}
if(ncol(t)>1) warning("this method is only valid for exact stage durations: variable stage durations not supported. Only first column of input 't' was used in this analysis")
if(ncol(js)>1) warning("this method is only valid for constant survival within stage: survival 'ramp' not supported. Only first column of input 'js' was used in this analysis")
m0
}
## Function for incorrect "FAS" method ------------
# function for implementing the incorrect "FAS" method (used in Gopher Tortoise SSA model)
do_fas <- function(js,as,f,t){
init_input_check(js,as,f,t)
ss = c(js[[1]],as)
n=length(ss); m0 <- matrix(0,n,n) ; m0[n,n] <- ss[n] ;  m0[1,n] <- f    # construct init matrix
gam <- 1/t[[1]]    # fraction of stage that is in the transition age
for(g in 1:(n-1)) m0[g:(g+1),g] <- c(ss[g]*(1-gam[g]), ss[g]*gam[g] )
warning("this method is incorrect in most cases and can be highly misleading in many real-world species")
if(ncol(t)>1) warning("variable stage durations not supported. Only first column of input 't' was used in this analysis")
if(ncol(js)>1) warning("this method is only valid for constant survival within stage: survival 'ramp' not supported. Only first column of input 'js' was used in this analysis")
m0
}
## Variable age at maturity functions ------------
### Function to compute the objective of max entropy (minimize the negative entropy) for discrete distribution
negent = function(p){
sum(p*log(p))
}
### Closure for generating equality constraint function- assume equality constraints are zeros a.la lagrange multiplier method
# ages are the possible ages for this stage,
# mean is the point estimate for maturation,
# sd is the standard deviation from the mean,
# skew is the skewness (third central moment, standardized by dividing by sigma cubed)
generate_eq = function(ages, mage){
sig=(max(ages)-min(ages))/5
function(p){
z1 = sum(p)-1       # constraint 1: sum to 1
thismean = sum(p*ages)
z2 = thismean - mage   # constraint 2: match user defined mean
this2cm = sum((ages-mage)^2 * p)
z3 = this2cm-sig^2  # constraint 3: match user defined second central moment
c(z1,z2,z3)  # z4
}
}
# ages=1:10;mage=5.5    #;skew=0
ineq = function(p){
diff(diff(log(p)))
}
# sum(s$pars)
# s$pars
# plot(s$pars)
# sum(ages*s$pars)
# sqrt(sum((ages-m)^2*s$pars))
# sum((ages-m)^3*s$pars)/(sig^3)
### Function for allocating stage durations in variable stage duration model
meand=9;mind=5;maxd=12
vari_dur <- function(meand, mind, maxd){
dur <- floor(mind):ceiling(maxd)
p0 = dnorm(dur,meand,(maxd-mind)/4) ; p0= p0/sum(p0)
bounds = cbind(rep(1e-9,length(dur)),rep(1-1e-9,length(dur)))
eq = generate_eq(dur,meand)
s = solnp(pars=p0, fun = negent,
eqfun = eq, eqB = c(0,0,0),
ineqfun = ineq, ineqLB = rep(-1e9,length(dur)-2), ineqUB=rep(0,length(dur)-2),
LB=bounds[,1],UB=bounds[,2], control = list(trace=0))   #
data.frame(
dur=dur,
prob=s$pars
# cprob=pmax(0,pmin(1,c(s$pars[1], s$pars[2:length(dur)] / (1-cumsum(s$pars))[1:(length(dur)-1)]) ))
)
}
vari_dur = memoize(vari_dur)
# FUNCTIONS for matrix population modeling in R ----------
# Load packages -----------
library(popbio)  # package for matrix population models
library(Rsolnp)   # package for nonlinear constrained optimization (eg. for finding maxent probability distributions)
library(memoise)
## Initial error checking function ------------
# s is stage specific survival, l is lambda, T is focal stage duration
init_input_check <- function(js,as,f,t){
if (!is.data.frame(js)) {
stop("Argument 'js' (juv surv) must be data frame")
}
if (!all(sapply(js,is.numeric))){
stop("All columns of data frame 'js' must be numeric")
}
if (length(as)>1) {
stop("adult survival must be a single value")
}
if (!is.numeric(as)){
stop("adult survival must be numeric")
}
if (length(f)>1) {
stop("fecundity must be a single value")
}
if (!is.numeric(f)){
stop("fecundity must be numeric")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
## Scenario generating function -------------
gen_scen <- function(jsurv,asurv,fec,dur){
if(is.vector(dur)) dur = data.frame(dur=dur)
nst = length(jsurv) + 1
if(is.vector(jsurv)) jsurv = data.frame(mean=jsurv)
scen <- list()
scen$jsurv = jsurv
scen$asurv = asurv
scen$fec = fec  # annual fecundity (assume pre-breeding census- this represents the number of new one-year-olds entering the population next year)
scen$dur = dur  # duration of juvenile stage (mean, min, max)
scen
}
## Functions for AAS method ---------------
#  Assume pre-breeding census
#  s is vector of survival, f is fecundity (scalar), t is duration of juvenile stage
#  l is lambda, mat is a stage matrix...
gamma_aas <- function(s,l,t){
sl = s/l
if(sl==1) 0.5 else (sl^(t-1)*(1-sl)) / (1-sl^t)  # note that the formula involves the sum of finite geometric series so can be simplified
}
# s is survival of focal stage, l is current lambda estimate, t is duration of focal stage
thistrans_aas <- function(s,l,t){
gam = gamma_aas(s,l,t)   # compute gamma (fraction of survivors transitioning)
c(s*(1-gam),s*gam)    # allocate the transitions
}
# s is survival of all stages, f is fecundity of final stage, t is duration of juvenile stages
do_aas <- function(js,as,f,t){
init_input_check(js,as,f,t)
ss = c(js[[1]],as)
n=length(ss); m0 <- matrix(0,n,n) ; m0[n,n] <- ss[n] ;  m0[1,n] <- f    # construct init matrix
lam = 1  # take an initial guess at lambda
dif=Inf ; tol=1e-6
while(dif>tol){
l = popbio::lambda(m0)
for(g in 1:(n-1)) m0[g:(g+1),g] = thistrans_aas(ss[g],l,t[[1]][g])
dif = abs(lambda(m0) - l)
}
if(ncol(t)>1) warning("this method is only valid for exact stage durations: variable stage durations not supported. Only first column of input 't' was used in this analysis")
if(ncol(js)>1) warning("this method is only valid for constant survival within stage: survival 'ramp' not supported. Only first column of input 'js' was used in this analysis")
m0
}
## Function for incorrect "FAS" method ------------
# function for implementing the incorrect "FAS" method (used in Gopher Tortoise SSA model)
do_fas <- function(js,as,f,t){
init_input_check(js,as,f,t)
ss = c(js[[1]],as)
n=length(ss); m0 <- matrix(0,n,n) ; m0[n,n] <- ss[n] ;  m0[1,n] <- f    # construct init matrix
gam <- 1/t[[1]]    # fraction of stage that is in the transition age
for(g in 1:(n-1)) m0[g:(g+1),g] <- c(ss[g]*(1-gam[g]), ss[g]*gam[g] )
warning("this method is incorrect in most cases and can be highly misleading in many real-world species")
if(ncol(t)>1) warning("variable stage durations not supported. Only first column of input 't' was used in this analysis")
if(ncol(js)>1) warning("this method is only valid for constant survival within stage: survival 'ramp' not supported. Only first column of input 'js' was used in this analysis")
m0
}
## Variable age at maturity functions ------------
### Function to compute the objective of max entropy (minimize the negative entropy) for discrete distribution
negent = function(p){
sum(p*log(p))
}
### Closure for generating equality constraint function- assume equality constraints are zeros a.la lagrange multiplier method
# ages are the possible ages for this stage,
# mean is the point estimate for maturation,
# sd is the standard deviation from the mean,
# skew is the skewness (third central moment, standardized by dividing by sigma cubed)
generate_eq = function(ages, mage){
sig=(max(ages)-min(ages))/5
function(p){
z1 = sum(p)-1       # constraint 1: sum to 1
thismean = sum(p*ages)
z2 = thismean - mage   # constraint 2: match user defined mean
this2cm = sum((ages-mage)^2 * p)
z3 = this2cm-sig^2  # constraint 3: match user defined second central moment
c(z1,z2,z3)  # z4
}
}
# ages=1:10;mage=5.5    #;skew=0
ineq = function(p){
diff(diff(log(p)))
}
# sum(s$pars)
# s$pars
# plot(s$pars)
# sum(ages*s$pars)
# sqrt(sum((ages-m)^2*s$pars))
# sum((ages-m)^3*s$pars)/(sig^3)
### Function for allocating stage durations in variable stage duration model
meand=9;mind=5;maxd=12
vari_dur <- function(meand, mind, maxd){
dur <- floor(mind):ceiling(maxd)
p0 = dnorm(dur,meand,(maxd-mind)/4) ; p0= p0/sum(p0)
bounds = cbind(rep(1e-9,length(dur)),rep(1-1e-9,length(dur)))
eq = generate_eq(dur,meand)
s = solnp(pars=p0, fun = negent,
eqfun = eq, eqB = c(0,0,0),
ineqfun = ineq, ineqLB = rep(-1e9,length(dur)-2), ineqUB=rep(0,length(dur)-2),
LB=bounds[,1],UB=bounds[,2], control = list(trace=0))   #
data.frame(
dur=dur,
prob=s$pars
# cprob=pmax(0,pmin(1,c(s$pars[1], s$pars[2:length(dur)] / (1-cumsum(s$pars))[1:(length(dur)-1)]) ))
)
}
vari_dur = memoize(vari_dur)
# sm = 0.75; sa = 0.5; sz = 0.95; y= 5    # note: t should be integer
ramp_fun = function(sm,sa,sz,y){
opt_func = function(k){
msurv = mean( sa + (sz-sa) * ( (1-exp(-k * (seq(1,y,length=20)-1) ) ) / (1-exp(-k * (y - 1) ) ) ) )
abs(msurv-sm)
}
opt = optimize(opt_func,c(-10,10))
thisk = opt$minimum
sa + (sz-sa) * ( (1-exp(-thisk * ( 1:y - 1 ) ) ) / (1 - exp(-thisk * (y - 1) ) ) )
}
plot(1:10,ramp_fun(0.8,0.5,0.96,10),type="l")
plot(1:10,ramp_fun(0.7,0.5,0.9,10),type="l")
plot(1:10,ramp_fun(0.9,0.5,0.9,10),type="l")
plot(1:10,ramp_fun(0.85,0.5,0.9,10),type="l")
plot(1:10,ramp_fun(0.75,0.5,0.9,10),type="l")
plot(1:10,ramp_fun(0.75,0.5,0.99,10),type="l")
plot(1:10,ramp_fun(0.8,0.5,0.9,10),type="l")
2400*5
