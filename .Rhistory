gen_scen(surv=c(x$jvsurv,x$adsurv),fec=x$fecundity,dur=x$TT)
} else{
gen_scen(surv=c(x$jvsurv,x$adsurv),fec=x$fecundity,dur=data.frame(dur=x$TT,min=min,max=max))
}
}
shovein(x)
paramlist = lapply(1:nrow(lhs_df),function(placeholder) shovein(lhs_df[placeholder,]))
shoveshovein = lapply(paramlist,function(placeholder) do_unroll(placeholder$surv,placeholder$fec,placeholder$dur))
paramlist[[1]]
placeholder = paramlist[[1]]
do_unroll(placeholder$surv,placeholder$fec,placeholder$dur)
paramlist = lapply(1:nrow(lhs_df),function(placeholder) shovein(lhs_df[placeholder,]))
shoveshovein = lapply(paramlist,function(placeholder) do_unroll(placeholder$surv,placeholder$fec,placeholder$dur))
paramlist[[1]]
placeholder = paramlist[[1]]
do_unroll(scen3$surv,scen3$fec,scen3$dur)
sapply(shoveshovein,lambda)
View(lhs_df)
View(paramlist)
closeallapplications()
get_lambdas_df <- function(lhs_df, shoveshovein) {
# helper to compute dominant eigenvalue (lambda)
get_lambda <- function(mat) {
# try popbio::lambda first, otherwise use eigen()
val <- tryCatch({
popbio::lambda(mat)
}, error = function(e) {
ev <- eigen(mat)$values
Re(ev[which.max(Mod(ev))])  # dominant real eigenvalue
})
return(as.numeric(val))
}
# compute all lambdas
lambdas <- sapply(shoveshovein, get_lambda)
# combine into one dataframe
result <- cbind(lhs_df, lambda = lambdas)
return(as.data.frame(result))
}
return(as.data.frame(result))
# combine into one dataframe
result <- cbind(lhs_df, lambda = lambdas)
# compute all lambdas
lambdas <- sapply(shoveshovein, get_lambda)
# compute all lambdas
lambdas <- sapply(shoveshovein, get_lambda_df)
get_lambdas_df <- function(lhs_df, shoveshovein) {
# helper to compute dominant eigenvalue (lambda)
get_lambda <- function(mat) {
# try popbio::lambda first, otherwise use eigen()
val <- tryCatch({
popbio::lambda(mat)
}, error = function(e) {
ev <- eigen(mat)$values
Re(ev[which.max(Mod(ev))])  # dominant real eigenvalue
})
return(as.numeric(val))
}
# compute all lambdas
lambdas <- sapply(shoveshovein, get_lambda_df)
# combine into one dataframe
result <- cbind(lhs_df, lambda = lambdas)
return(as.data.frame(result))
}
# --- Example usage ---
lambda_results <- get_lambdas_df(lhs_df, shoveshovein)
# helper to compute dominant eigenvalue (lambda)
get_lambda <- function(mat) {
# try popbio::lambda first, otherwise use eigen()
val <- tryCatch({
popbio::lambda(mat)
}, error = function(e) {
ev <- eigen(mat)$values
Re(ev[which.max(Mod(ev))])  # dominant real eigenvalue
})
return(as.numeric(val))
}
# --- Example usage ---
lambda_results <- get_lambdas_df(lhs_df, shoveshovein)
# --- Define the function ---
get_lambdas_df <- function(lhs_df, shoveshovein) {
# helper to compute dominant eigenvalue (lambda)
get_lambda <- function(mat) {
val <- tryCatch({
popbio::lambda(mat)
}, error = function(e) {
ev <- eigen(mat)$values
Re(ev[which.max(Mod(ev))])  # dominant real eigenvalue
})
return(as.numeric(val))
}
# compute all lambdas
lambdas <- sapply(shoveshovein, get_lambda)
# combine into one dataframe
result <- cbind(lhs_df, lambda = lambdas)
return(as.data.frame(result))
}
# --- Example usage ---
lambda_results <- get_lambdas_df(lhs_df, shoveshovein)
View(lambda_results)
lhs_df <- get_lambdas_df(lhs_df, shoveshovein)
View(lhs_df)
n_samples = 100000 #is this supposed to be 100 I forgot oops OK change to 100k
lhs_raw <- randomLHS(n_samples,n_params)
#convert into actual parameter samples
lhs <- lhs_raw
#generate raw LHS
lhs_raw <- randomLHS(n_samples, n_params)
#helper to map [0,1] -> [min,max]
map_range <- function(u, min_val, max_val) {
min_val + u * (max_val - min_val)
}
#generate raw LHS
lhs_raw <- randomLHS(n_samples, n_params)
#convert LHS into actual parameter values based off:
#lhs$clutchsize <-min(clutchsize) + lhs_raw[,1]*diff(range(clutchsize))
lhs_df <- as.data.frame(lhs_raw)
colnames(lhs_df) <- c("clutchsize_u","nestsurv_u","propfem_u","hatchrate_u","hatchsurv_u","jvsurv_u","adsurv_u","TT_u", "vari_u")
lhs_df <- lhs_df %>%
mutate(
clutchsize = round(map_range(clutchsize_u, clutchsize_range[1], clutchsize_range[2])), # integer
nestsurv  = map_range(nestsurv_u,  nestsurv_range[1],  nestsurv_range[2]),
propfem   = map_range(propfem_u,   propfem_range[1],   propfem_range[2]),
hatchrate = map_range(hatchrate_u, hatchrate_range[1], hatchrate_range[2]),
hatchsurv = map_range(hatchsurv_u, hatchsurv_range[1], hatchsurv_range[2]),
jvsurv   = map_range(jvsurv_u,   jvsurv_range[1],   jvsurv_range[2]),
adsurv    = map_range(adsurv_u,    adsurv_range[1],    adsurv_range[2]),
TT        = round(map_range(TT_u,   TT_range[1],        TT_range[2])),              # integer
varimature = floor(map_range(vari_u,   varimature_range[1],        varimature_range[2]))
) %>%
#lhs$fec <- everything multipled by each other so lhs$clutchsize*lhs$nestsurv*lhs$propfem*lhs$hatchrate*lhs$hatchsurv
# fecundity function
mutate(
fecundity = clutchsize * nestsurv * propfem * hatchrate * hatchsurv
) %>%
# keep only the mapped columns (drop the _u columns)
select(clutchsize, nestsurv, propfem, hatchrate, hatchsurv, jvsurv, adsurv, TT, fecundity, varimature)
#then run scenarios and see what parameters produce growing populations?
init_input_check <- function(s,f,t){
if (!is.numeric(s)) {
stop("Argument 's' must be numeric")
}
if (length(s)<2) {
stop("Argument 's' must have two or more elements (one juv stage and one adult stage)")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
init_input_check <- function(s,f,t){
if (!is.numeric(s)) {
stop("Argument 's' must be numeric")
}
if (length(s)<2) {
stop("Argument 's' must have two or more elements (one juv stage and one adult stage)")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
gen_scen <- function(surv,fec,dur){
if(is.vector(dur)) dur = data.frame(dur=dur)
scen <- list()
scen$surv = surv # one survival rate per stage
scen$fec = fec  # annual fecundity (assume pre-breeding census- this represents the number of new one-year-olds entering the population next year)
scen$dur = dur  # duration of juvenile stage (mean, min, max)
scen
}
gamma_aas <- function(s,l,t){
sl = s/l
if(sl==1) 0.5 else (sl^(t-1)*(1-sl)) / (1-sl^t)  # note that the formula involves the sum of finite geometric series so can be simplified
}
# s is survival of focal stage, l is current lambda estimate, t is duration of focal stage
thistrans_aas <- function(s,l,t){
gam = gamma_aas(s,l,t)   # compute gamma (fraction of survivors transitioning)
c(s*(1-gam),s*gam)    # allocate the transitions
}
# s is survival of all stages, f is fecundity of final stage, t is duration of juvenile stages
do_aas <- function(s,f,t){
init_input_check(s,f,t)
n=length(s); m0 <- matrix(0,n,n) ; m0[n,n] <- s[n] ;  m0[1,n] <- f    # construct init matrix
lam = 1  # take an initial guess at lambda
dif=Inf ; tol=1e-6
while(dif>tol){
l = lambda(m0)
for(g in 1:(n-1)) m0[g:(g+1),g] = thistrans_aas(s[g],l,t[[1]][g])
dif = abs(lambda(m0) - l)
}
if(ncol(t)>1) warning("this method is only valid for exact stage durations: variable stage durations not supported. Only first column of input 't' was used in this analysis")
m0
}
# function for implementing the incorrect "FAS" method (used in Gopher Tortoise SSA model)
do_fas <- function(s,f,t){
init_input_check(s,f,t)
n=length(s); m0 <- matrix(0,n,n) ; m0[n,n] <- s[n] ;  m0[1,n] <- f    # construct init matrix
gam <- 1/t[[1]]    # fraction of stage that is in the transition age
for(g in 1:(n-1)) m0[g:(g+1),g] <- c(s[g]*(1-gam[g]), s[g]*gam[g] )
warning("this method is incorrect in most cases and can be highly misleading in many real-world species")
if(ncol(t)>1) warning("variable stage durations not supported. Only first column of input 't' was used in this analysis")
m0
}
### Function to compute the objective of max entropy (minimize the negative entropy) for discrete distribution
negent = function(p){
sum(p*log(p))
}
### Closure for generating equality constraint function- assume equality constraints are zeros a.la lagrange multiplier method
# ages are the possible ages for this stage,
# mean is the point estimate for maturation,
# sd is the standard deviation from the mean,
# skew is the skewness (third central moment, standardized by dividing by sigma cubed)
generate_eq = function(ages, mage){
sig=(max(ages)-min(ages))/5
function(p){
z1 = sum(p)-1       # constraint 1: sum to 1
thismean = sum(p*ages)
z2 = thismean - mage   # constraint 2: match user defined mean
this2cm = sum((ages-mage)^2 * p)
z3 = this2cm-sig^2  # constraint 3: match user defined second central moment
c(z1,z2,z3)  # z4
}
}
ineq = function(p){
diff(diff(log(p)))
}
### Function for allocating age at maturity in variable-maturity age-structured model
meanam=9;minam=5;maxam=12
### Function for allocating age at maturity in variable-maturity age-structured model
meanam=9;minam=5;maxam=12
age_at_mat <- function(meanam, minam, maxam){
aam <- minam:maxam
p0 = dnorm(aam,meanam,(maxam-minam)/4) ; p0= p0/sum(p0)
bounds = cbind(rep(1e-9,length(aam)),rep(1-1e-9,length(aam)))
eq = generate_eq(aam,meanam)
sink("new");
s = solnp(pars=p0, fun = negent,
eqfun = eq, eqB = c(0,0,0),
ineqfun = ineq, ineqLB = rep(-1e9,length(aam)-2), ineqUB=rep(0,length(aam)-2),
LB=bounds[,1],UB=bounds[,2])   #
sink()
data.frame(
ages=aam,
prob=s$pars
)
}
do_unroll <- function(s,f,t){
init_input_check(s,f,t)
na = sum(t[[ncol(t)]])+1; ns = nrow(t)   # na is number of age classes, ns is number of juv stage classes
m0 <- matrix(0,na,na) ;  m0[1,na] <- f;  m0[na,na] <- s[ns+1]    # construct init matrix
if(ncol(t)>1){
td = lapply(1:nrow(t),function(z) age_at_mat(t[z,1],t[z,2],t[z,3] )   )
for(r in 1:nrow(t)){
pr1 = numeric(t[r,3]);pr2=pr1  # probability of moving on to the next stage
pr1[td[[r]]$ages ] <- td[[r]]$prob
# hard coded to go right to adult (assuming only 1 juvenile stage for now)
for(a in 2:(na-1)) pr2[a] = pr1[a]/(1-sum(pr1[1:(a-1)]) )     # prob of transitioning conditional on not having previously transitioned
pr2 = pmax(0,pmin(1,pr2))
m1 <- diag(s[r]*(1-pr2))
m1[na-1,] <- s[r]*pr2
m0[2:na,1:(na-1)] = m1
}
}else{
m1 <- diag(rep(s[1:ns],t[[1]]))
m0[2:na,1:(na-1)] = m1
}
m0
}
#putting tortoise into unroll
x = lhs_df[2,]
#helper function for min max
shovein=function(x){
qd = x$TT/4
min = x$TT-x$varimature*qd
max = x$TT+x$varimature*qd
if (x$varimature==0){
gen_scen(surv=c(x$jvsurv,x$adsurv),fec=x$fecundity,dur=x$TT)
} else{
gen_scen(surv=c(x$jvsurv,x$adsurv),fec=x$fecundity,dur=data.frame(dur=x$TT,min=min,max=max))
}
}
shovein(x)
paramlist = lapply(1:nrow(lhs_df),function(placeholder) shovein(lhs_df[placeholder,]))
shoveshovein = lapply(paramlist,function(placeholder) do_unroll(placeholder$surv,placeholder$fec,placeholder$dur))
View(lhs_df)
View(paramlist)
View(paramlist)
library(popbio)
library(purrr)
library(dplyr)
library(tidyr)
library(lhs)
library(Rsolnp)
#get ranges
#parameter ranges
clutchsize_range <- c(4, 12)
nestsurv_range  <- c(0.15, 0.55)
propfem_range   <- c(0.5, 0.8)
hatchsurv_range <- c(0.05, 0.4)
hatchrate_range <- c(0.75, 0.95)
jvsurv_range   <- c(0.63, 0.91)
adsurv_range    <- c(0.92, 0.99)
TT_range        <- c(8, 20)
varimature_range <- c(0,3) #integer
#latin heighten cube sampling???
set.seed(42)
n_params = 9
n_samples = 10000 #is this supposed to be 100 I forgot oops OK change to 100k
lhs_raw <- randomLHS(n_samples,n_params)
#convert into actual parameter samples
lhs <- lhs_raw
#generate raw LHS
lhs_raw <- randomLHS(n_samples, n_params)
#helper to map [0,1] -> [min,max]
map_range <- function(u, min_val, max_val) {
min_val + u * (max_val - min_val)
}
#convert LHS into actual parameter values based off:
#lhs$clutchsize <-min(clutchsize) + lhs_raw[,1]*diff(range(clutchsize))
lhs_df <- as.data.frame(lhs_raw)
colnames(lhs_df) <- c("clutchsize_u","nestsurv_u","propfem_u","hatchrate_u","hatchsurv_u","jvsurv_u","adsurv_u","TT_u", "vari_u")
lhs_df <- lhs_df %>%
mutate(
clutchsize = round(map_range(clutchsize_u, clutchsize_range[1], clutchsize_range[2])), # integer
nestsurv  = map_range(nestsurv_u,  nestsurv_range[1],  nestsurv_range[2]),
propfem   = map_range(propfem_u,   propfem_range[1],   propfem_range[2]),
hatchrate = map_range(hatchrate_u, hatchrate_range[1], hatchrate_range[2]),
hatchsurv = map_range(hatchsurv_u, hatchsurv_range[1], hatchsurv_range[2]),
jvsurv   = map_range(jvsurv_u,   jvsurv_range[1],   jvsurv_range[2]),
adsurv    = map_range(adsurv_u,    adsurv_range[1],    adsurv_range[2]),
TT        = round(map_range(TT_u,   TT_range[1],        TT_range[2])),              # integer
varimature = floor(map_range(vari_u,   varimature_range[1],        varimature_range[2]))
) %>%
#lhs$fec <- everything multipled by each other so lhs$clutchsize*lhs$nestsurv*lhs$propfem*lhs$hatchrate*lhs$hatchsurv
# fecundity function
mutate(
fecundity = clutchsize * nestsurv * propfem * hatchrate * hatchsurv
) %>%
# keep only the mapped columns (drop the _u columns)
select(clutchsize, nestsurv, propfem, hatchrate, hatchsurv, jvsurv, adsurv, TT, fecundity, varimature)
#then run scenarios and see what parameters produce growing populations?
init_input_check <- function(s,f,t){
if (!is.numeric(s)) {
stop("Argument 's' must be numeric")
}
if (length(s)<2) {
stop("Argument 's' must have two or more elements (one juv stage and one adult stage)")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
init_input_check <- function(s,f,t){
if (!is.numeric(s)) {
stop("Argument 's' must be numeric")
}
if (length(s)<2) {
stop("Argument 's' must have two or more elements (one juv stage and one adult stage)")
}
if (!is.data.frame(t)) {
stop("Argument 't' must be a data frame")
}
if (!all(sapply(t,is.numeric))){
stop("All columns of data frame 't' must be numeric")
}
if (!ncol(t)%in%c(1,3)){
stop("Data frame 't' have either 1 column or 3 columns (mean, min, and max duration)")
}
}
gen_scen <- function(surv,fec,dur){
if(is.vector(dur)) dur = data.frame(dur=dur)
scen <- list()
scen$surv = surv # one survival rate per stage
scen$fec = fec  # annual fecundity (assume pre-breeding census- this represents the number of new one-year-olds entering the population next year)
scen$dur = dur  # duration of juvenile stage (mean, min, max)
scen
}
gamma_aas <- function(s,l,t){
sl = s/l
if(sl==1) 0.5 else (sl^(t-1)*(1-sl)) / (1-sl^t)  # note that the formula involves the sum of finite geometric series so can be simplified
}
# s is survival of focal stage, l is current lambda estimate, t is duration of focal stage
thistrans_aas <- function(s,l,t){
gam = gamma_aas(s,l,t)   # compute gamma (fraction of survivors transitioning)
c(s*(1-gam),s*gam)    # allocate the transitions
}
# s is survival of all stages, f is fecundity of final stage, t is duration of juvenile stages
do_aas <- function(s,f,t){
init_input_check(s,f,t)
n=length(s); m0 <- matrix(0,n,n) ; m0[n,n] <- s[n] ;  m0[1,n] <- f    # construct init matrix
lam = 1  # take an initial guess at lambda
dif=Inf ; tol=1e-6
while(dif>tol){
l = lambda(m0)
for(g in 1:(n-1)) m0[g:(g+1),g] = thistrans_aas(s[g],l,t[[1]][g])
dif = abs(lambda(m0) - l)
}
if(ncol(t)>1) warning("this method is only valid for exact stage durations: variable stage durations not supported. Only first column of input 't' was used in this analysis")
m0
}
# function for implementing the incorrect "FAS" method (used in Gopher Tortoise SSA model)
do_fas <- function(s,f,t){
init_input_check(s,f,t)
n=length(s); m0 <- matrix(0,n,n) ; m0[n,n] <- s[n] ;  m0[1,n] <- f    # construct init matrix
gam <- 1/t[[1]]    # fraction of stage that is in the transition age
for(g in 1:(n-1)) m0[g:(g+1),g] <- c(s[g]*(1-gam[g]), s[g]*gam[g] )
warning("this method is incorrect in most cases and can be highly misleading in many real-world species")
if(ncol(t)>1) warning("variable stage durations not supported. Only first column of input 't' was used in this analysis")
m0
}
### Function to compute the objective of max entropy (minimize the negative entropy) for discrete distribution
negent = function(p){
sum(p*log(p))
}
### Closure for generating equality constraint function- assume equality constraints are zeros a.la lagrange multiplier method
# ages are the possible ages for this stage,
# mean is the point estimate for maturation,
# sd is the standard deviation from the mean,
# skew is the skewness (third central moment, standardized by dividing by sigma cubed)
generate_eq = function(ages, mage){
sig=(max(ages)-min(ages))/5
function(p){
z1 = sum(p)-1       # constraint 1: sum to 1
thismean = sum(p*ages)
z2 = thismean - mage   # constraint 2: match user defined mean
this2cm = sum((ages-mage)^2 * p)
z3 = this2cm-sig^2  # constraint 3: match user defined second central moment
c(z1,z2,z3)  # z4
}
}
ineq = function(p){
diff(diff(log(p)))
}
age_at_mat <- function(meanam, minam, maxam){
aam <- minam:maxam
p0 = dnorm(aam,meanam,(maxam-minam)/4) ; p0= p0/sum(p0)
bounds = cbind(rep(1e-9,length(aam)),rep(1-1e-9,length(aam)))
eq = generate_eq(aam,meanam)
sink("new");
s = solnp(pars=p0, fun = negent,
eqfun = eq, eqB = c(0,0,0),
ineqfun = ineq, ineqLB = rep(-1e9,length(aam)-2), ineqUB=rep(0,length(aam)-2),
LB=bounds[,1],UB=bounds[,2])   #
sink()
data.frame(
ages=aam,
prob=s$pars
)
}
do_unroll <- function(s,f,t){
init_input_check(s,f,t)
na = sum(t[[ncol(t)]])+1; ns = nrow(t)   # na is number of age classes, ns is number of juv stage classes
m0 <- matrix(0,na,na) ;  m0[1,na] <- f;  m0[na,na] <- s[ns+1]    # construct init matrix
if(ncol(t)>1){
td = lapply(1:nrow(t),function(z) age_at_mat(t[z,1],t[z,2],t[z,3] )   )
for(r in 1:nrow(t)){
pr1 = numeric(t[r,3]);pr2=pr1  # probability of moving on to the next stage
pr1[td[[r]]$ages ] <- td[[r]]$prob
# hard coded to go right to adult (assuming only 1 juvenile stage for now)
for(a in 2:(na-1)) pr2[a] = pr1[a]/(1-sum(pr1[1:(a-1)]) )     # prob of transitioning conditional on not having previously transitioned
pr2 = pmax(0,pmin(1,pr2))
m1 <- diag(s[r]*(1-pr2))
m1[na-1,] <- s[r]*pr2
m0[2:na,1:(na-1)] = m1
}
}else{
m1 <- diag(rep(s[1:ns],t[[1]]))
m0[2:na,1:(na-1)] = m1
}
m0
}
#putting tortoise into unroll
x = lhs_df[2,]
library(furrr)
make_paramlist_parallel <- function(lhs_df, workers = parallel::detectCores() - 1) {
plan(multisession, workers = workers)
paramlist <- future_pmap(
lhs_df,
function(clutchsize, nestsurv, propfem, hatchrate, hatchsurv,
jvsurv, adsurv, TT, fecundity, varimature) {
x <- tibble(
clutchsize = clutchsize, nestsurv = nestsurv, propfem = propfem,
hatchrate = hatchrate, hatchsurv = hatchsurv,
jvsurv = jvsurv, adsurv = adsurv, TT = TT,
fecundity = fecundity, varimature = varimature
)
shovein(x)
}
)
return(paramlist)
}
paramlist <- make_paramlist_parallel(lhs_df)
shovein(x)
paramlist = lapply(1:nrow(lhs_df),function(placeholder) shovein(lhs_df[placeholder,]))
shoveshovein = lapply(paramlist,function(placeholder) do_unroll(placeholder$surv,placeholder$fec,placeholder$dur))
shoveshovein = lapply(paramlist,function(placeholder) do_unroll(placeholder$surv,placeholder$fec,placeholder$dur))
View(lhs_df)
